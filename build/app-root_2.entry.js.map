{"version":3,"sources":["src/assets/ts/image-loader.ts","src/components/App/app-root.tsx","node_modules/@stencil/store/dist/index.mjs","node_modules/stencil-router-v2/dist/index.mjs","src/static-router/static-router.tsx"],"names":["ImageLoader","[object Object]","options","this","queue","backgroundQueue","lazyImageObserver","lazyBgObserver","getImagesToLazyLoad","window","abort","onContentLoaded","setGenericPlaceholder","forEach","lazyImage","observe","lazyBg","document","querySelectorAll","genericImagePlaceholder","img","setAttribute","genericBgPlaceholder","bg","style","backgroundColor","IntersectionObserver","entries","entry","isIntersecting","target","classList","contains","dataset","src","srcset","remove","add","unobserve","webP","getAttribute","webpSupported","i","length","AppRoot","globalThis","imageLoader","initialize","setTimeout","hash","location","elem","getElementById","substring","scrollIntoView","h","class","appendToMap","map","propName","value","items","get","set","includes","push","debounce","fn","ms","timeoutId","args","clearTimeout","isConnected","maybeElement","cleanupElements","key","keys","filter","stencilSubscription","getRenderingRef","elmsToUpdate","Map","dispose","clear","elm","elements","forceUpdate","reset","elms","createObservableMap","defaultState","shouldUpdate","a","b","states","Object","handlers","cb","oldValue","state","Proxy","_","Array","from","enumerable","configurable","has","on","eventName","callback","removeFromArray","onChange","unSet","newValue","unReset","use","subscriptions","unsubs","reduce","subscription","unsub","array","item","index","indexOf","createStore","createRouter","opts","_a","win","url","URL","href","parseURL","DEFAULT_PARSE_URL","activePath","newV","oldV","prop","history","pushState","baseURI","match","routes","route","params","matchPath","path","to","undefined","navigationChanged","Switch","childrenRoutes","result","jsx","disposeRouter","removeEventListener","router","addEventListener","Route","props","children","id","render","pathname","results","exec","lastIndex","toLowerCase","Router","StaticRouter","fetchContents","fetch","then","response","ok","text","Error","data","parser","DOMParser","markup","parseFromString","firstElementChild","outerHTML","body","querySelector","injectBodyScripts","catch","error","console","scripts","script","injectedScript","createElement","innerHTML","appendChild"],"mappings":";;;;sGAYaA,EAaTC,YAAYC,EAAU,IAClBC,KAAKC,MAAQ,GACbD,KAAKE,gBAAkB,GACvBF,KAAKG,kBAAoB,KACzBH,KAAKI,eAAiB,KACtBJ,KAAKD,QAAUA,EAGZD,aACHE,KAAKC,MAAQ,GACbD,KAAKE,gBAAkB,GACvBF,KAAKG,kBAAoB,KACzBH,KAAKI,eAAiB,KAEtBJ,KAAKK,sBAEL,KAAM,yBAA0BC,QAAS,CACrCN,KAAKO,QACL,OAGJP,KAAKQ,kBACLR,KAAKS,wBAELT,KAAKC,MAAMS,SAASC,IAChBX,KAAKG,kBAAkBS,QAAQD,MAGnCX,KAAKE,gBAAgBQ,SAASG,IAC1Bb,KAAKI,eAAeQ,QAAQC,MAIpCf,sBACIE,KAAKC,MAAQa,SAASC,iBAAiB,kBACvCf,KAAKE,gBAAkBY,SAASC,iBAAiB,iBAGrDjB,wBACI,GAAIE,KAAKD,QAAQiB,wBAAyB,CACtChB,KAAKC,MAAMS,SAASO,IAChBA,EAAIC,aAAa,MAAOlB,KAAKD,QAAQiB,4BAI7C,GAAIhB,KAAKD,QAAQoB,qBAAsB,CACnCnB,KAAKE,gBAAgBQ,SAASU,IAE1BA,EAAGC,MAAMC,gBAAkBtB,KAAKD,QAAQoB,yBAKpDrB,kBACIE,KAAKG,kBAAoB,IAAIoB,sBAAsBC,IAC/CA,EAAQd,SAASe,IACb,GAAIA,EAAMC,eAAgB,CACtB,MAAMf,EAAiBc,EAAME,OAE7B,GAAIhB,EAAUiB,UAAUC,SAAS,iBAAkB,CAC/C,GAAIlB,EAAUmB,QAAQC,IAAK,CACvBpB,EAAUoB,IAAMpB,EAAUmB,QAAQC,IAEtC,GAAIpB,EAAUmB,QAAQE,OAAQ,CAC1BrB,EAAUqB,OAASrB,EAAUmB,QAAQE,OAEzCrB,EAAUiB,UAAUK,OAAO,iBAC3BtB,EAAUiB,UAAUM,IAAI,gBACxBlC,KAAKG,kBAAkBgC,UAAUxB,WAMjDX,KAAKI,eAAiB,IAAImB,sBAAsBC,IAC5CA,EAAQd,SAASe,IACb,GAAIA,EAAMC,gBAAkBD,EAAME,OAAOC,UAAUC,SAAS,gBAAiB,CACzE,MAAMO,EAAOX,EAAME,OAAOU,aAAa,aACvC,GAAIrC,KAAKsC,eAAiBF,GAAQA,IAAS,GAAI,CAC3CX,EAAME,OAAOT,aAAa,QAAS,yBAAyBkB,MAGhEX,EAAME,OAAOC,UAAUK,OAAO,gBAC9BR,EAAME,OAAOC,UAAUM,IAAI,gBAC3BlC,KAAKI,eAAe+B,UAAUV,EAAME,eAMpD7B,QACI,IAAK,IAAIyC,EAAI,EAAGA,EAAIvC,KAAKC,MAAMuC,OAAQD,GAAK,EAAG,CAC3CvC,KAAKC,MAAMsC,GAAGrB,aAAa,MAAOlB,KAAKC,MAAMsC,GAAGF,aAAa,aAC7DrC,KAAKC,MAAMsC,GAAGX,UAAUK,OAAO,iBAC/BjC,KAAKC,MAAMsC,GAAGX,UAAUM,IAAI,gBAGhC,IAAK,IAAIK,EAAI,EAAGA,EAAIvC,KAAKE,gBAAgBsC,OAAQD,GAAK,EAAG,CACrDvC,KAAKE,gBAAgBqC,GAAGX,UAAUK,OAAO,sBChHxCQ,EAAO,+BAChB3C,oBACI4C,WAAWC,YAAc,IAAI9C,EAGjCC,mBACI4C,WAAWC,YAAYC,aAG3B9C,qBACI+C,YAAW,KACP,MAAMC,KAAEA,GAASxC,OAAOyC,SACxB,GAAID,EAAM,CACN,MAAME,EAAOlC,SAASmC,eAAeH,EAAKI,UAAU,IACpD,GAAIF,EAAM,CACNA,EAAKG,qBAGd,KAGPrD,SACI,OACIsD,EAAA,MAAA,CAAKC,MAAM,YACPD,EAAA,OAAA,SCjChB,MAAME,EAAc,CAACC,EAAKC,EAAUC,KAChC,MAAMC,EAAQH,EAAII,IAAIH,GACtB,IAAKE,EAAO,CACRH,EAAIK,IAAIJ,EAAU,CAACC,SAElB,IAAKC,EAAMG,SAASJ,GAAQ,CAC7BC,EAAMI,KAAKL,KAGnB,MAAMM,EAAW,CAACC,EAAIC,KAClB,IAAIC,EACJ,MAAO,IAAIC,KACP,GAAID,EAAW,CACXE,aAAaF,GAEjBA,EAAYrB,YAAW,KACnBqB,EAAY,EACZF,KAAMG,KACPF,KAaX,MAAMI,EAAeC,KAAmB,gBAAiBA,IAAiBA,EAAaD,YACvF,MAAME,EAAkBR,GAAUR,IAC9B,IAAK,IAAIiB,KAAOjB,EAAIkB,OAAQ,CACxBlB,EAAIK,IAAIY,EAAKjB,EAAII,IAAIa,GAAKE,OAAOL,OAEtC,KACH,MAAMM,EAAsB,KACxB,UAAWC,IAAoB,WAAY,CAGvC,MAAO,GAEX,MAAMC,EAAe,IAAIC,IACzB,MAAO,CACHC,QAAS,IAAMF,EAAaG,QAC5BrB,IAAMH,IACF,MAAMyB,EAAML,IACZ,GAAIK,EAAK,CACL3B,EAAYuB,EAAcrB,EAAUyB,KAG5CrB,IAAMJ,IACF,MAAM0B,EAAWL,EAAalB,IAAIH,GAClC,GAAI0B,EAAU,CACVL,EAAajB,IAAIJ,EAAU0B,EAASR,OAAOS,IAE/CZ,EAAgBM,IAEpBO,MAAO,KACHP,EAAanE,SAAS2E,GAASA,EAAK3E,QAAQyE,KAC5CZ,EAAgBM,MAK5B,MAAMS,EAAsB,CAACC,EAAcC,EAAe,EAACC,EAAGC,IAAMD,IAAMC,MACtE,IAAIC,EAAS,IAAIb,IAAIc,OAAOpE,QAAQ+D,IAAiB,MAAQA,SAAsB,EAAIA,EAAe,KACtG,MAAMM,EAAW,CACbd,QAAS,GACTpB,IAAK,GACLC,IAAK,GACLwB,MAAO,IAEX,MAAMA,EAAQ,KACVO,EAAS,IAAIb,IAAIc,OAAOpE,QAAQ+D,IAAiB,MAAQA,SAAsB,EAAIA,EAAe,KAClGM,EAAST,MAAM1E,SAASoF,GAAOA,OAEnC,MAAMf,EAAU,KAGZc,EAASd,QAAQrE,SAASoF,GAAOA,MACjCV,KAEJ,MAAMzB,EAAOH,IACTqC,EAASlC,IAAIjD,SAASoF,GAAOA,EAAGtC,KAChC,OAAOmC,EAAOhC,IAAIH,IAEtB,MAAMI,EAAM,CAACJ,EAAUC,KACnB,MAAMsC,EAAWJ,EAAOhC,IAAIH,GAC5B,GAAIgC,EAAa/B,EAAOsC,EAAUvC,GAAW,CACzCmC,EAAO/B,IAAIJ,EAAUC,GACrBoC,EAASjC,IAAIlD,SAASoF,GAAOA,EAAGtC,EAAUC,EAAOsC,OAGzD,MAAMC,SAAgBC,QAAU,YAC1B,GACA,IAAIA,MAAMV,EAAc,CACtBzF,IAAIoG,EAAG1C,GACH,OAAOG,EAAIH,IAEf1D,QAAQoG,GACJ,OAAOC,MAAMC,KAAKT,EAAOlB,SAE7B3E,2BACI,MAAO,CACHuG,WAAY,KACZC,aAAc,OAGtBxG,IAAIoG,EAAG1C,GACH,OAAOmC,EAAOY,IAAI/C,IAEtB1D,IAAIoG,EAAG1C,EAAUC,GACbG,EAAIJ,EAAUC,GACd,OAAO,QAGnB,MAAM+C,EAAK,CAACC,EAAWC,KACnBb,EAASY,GAAW3C,KAAK4C,GACzB,MAAO,KACHC,EAAgBd,EAASY,GAAYC,KAG7C,MAAME,EAAW,CAACpD,EAAUsC,KACxB,MAAMe,EAAQL,EAAG,OAAO,CAAChC,EAAKsC,KAC1B,GAAItC,IAAQhB,EAAU,CAClBsC,EAAGgB,OAGX,MAAMC,EAAUP,EAAG,SAAS,IAAMV,EAAGP,EAAa/B,MAClD,MAAO,KACHqD,IACAE,MAGR,MAAMC,EAAM,IAAIC,KACZ,MAAMC,EAASD,EAAcE,QAAO,CAACD,EAAQE,KACzC,GAAIA,EAAaxD,IAAK,CAClBsD,EAAOpD,KAAK0C,EAAG,MAAOY,EAAaxD,MAEvC,GAAIwD,EAAazD,IAAK,CAClBuD,EAAOpD,KAAK0C,EAAG,MAAOY,EAAazD,MAEvC,GAAIyD,EAAahC,MAAO,CACpB8B,EAAOpD,KAAK0C,EAAG,QAASY,EAAahC,QAEzC,GAAIgC,EAAarC,QAAS,CACtBmC,EAAOpD,KAAK0C,EAAG,UAAWY,EAAarC,UAE3C,OAAOmC,IACR,IACH,MAAO,IAAMA,EAAOxG,SAAS2G,GAAUA,OAE3C,MAAMlC,EAAeX,IACjB,MAAMuB,EAAWJ,EAAOhC,IAAIa,GAC5BqB,EAASjC,IAAIlD,SAASoF,GAAOA,EAAGtB,EAAKuB,EAAUA,MAEnD,MAAO,CACHC,MAAAA,EACArC,IAAAA,EACAC,IAAAA,EACA4C,GAAAA,EACAI,SAAAA,EACAI,IAAAA,EACAjC,QAAAA,EACAK,MAAAA,EACAD,YAAAA,IAGR,MAAMwB,EAAkB,CAACW,EAAOC,KAC5B,MAAMC,EAAQF,EAAMG,QAAQF,GAC5B,GAAIC,GAAS,EAAG,CACZF,EAAME,GAASF,EAAMA,EAAM9E,OAAS,GACpC8E,EAAM9E,WAId,MAAMkF,EAAc,CAACnC,EAAcC,KAC/B,MAAMjC,EAAM+B,EAAoBC,EAAcC,GAC9CjC,EAAIyD,IAAIrC,KACR,OAAOpB,GCnLX,MAAMoE,EAAgBC,IAClB,IAAIC,EACJ,MAAMC,EAAMxH,OACZ,MAAMyH,EAAM,IAAIC,IAAIF,EAAI/E,SAASkF,MACjC,MAAMC,GAAYL,EAAKD,IAAS,MAAQA,SAAc,OAAS,EAAIA,EAAKM,YAAc,MAAQL,SAAY,EAAIA,EAAKM,EACnH,MAAMnC,MAAEA,EAAKY,SAAEA,EAAQ7B,QAAEA,GAAY2C,EAAY,CAC7CK,IAAAA,EACAK,WAAYF,EAASH,KACtB,CAACM,EAAMC,EAAMC,KACZ,GAAIA,IAAS,MAAO,CAChB,OAAOF,EAAKJ,OAASK,EAAKL,KAE9B,OAAOI,IAASC,KAEpB,MAAMxE,EAAQmE,IACVO,QAAQC,UAAU,KAAM,KAAMR,GAC9B,MAAMF,EAAM,IAAIC,IAAIC,EAAMnH,SAAS4H,SACnC1C,EAAM+B,IAAMA,EACZ/B,EAAMoC,WAAaF,EAASH,IAEhC,MAAMY,EAASC,IACX,MAAMR,WAAEA,GAAepC,EACvB,IAAK,IAAI6C,KAASD,EAAQ,CACtB,MAAME,EAASC,EAAUX,EAAYS,EAAMG,MAC3C,GAAIF,EAAQ,CACR,GAAID,EAAMI,IAAM,KAAM,CAClB,MAAMA,SAAaJ,EAAMI,KAAO,SAC1BJ,EAAMI,GACNJ,EAAMI,GAAGb,GACftE,EAAKmF,GACL,OAAON,EAAMC,OAEZ,CACD,MAAO,CAAEE,OAAAA,EAAQD,MAAAA,KAI7B,OAAOK,WAEX,MAAMC,EAAoB,KACtB,MAAMpB,EAAM,IAAIC,IAAIF,EAAI/E,SAASkF,MACjCjC,EAAM+B,IAAMA,EACZ/B,EAAMoC,WAAaF,EAASH,IAEhC,MAAMqB,EAAS,CAAClD,EAAGmD,KACf,MAAMC,EAASX,EAAMU,GACrB,GAAIC,EAAQ,CACR,UAAWA,EAAOT,MAAMU,MAAQ,WAAY,CACxC,OAAOD,EAAOT,MAAMU,IAAID,EAAOR,YAE9B,CACD,OAAOQ,EAAOT,MAAMU,OAIhC,MAAMC,EAAgB,KAElB1B,EAAI2B,oBAAoB,WAAYN,GACpCpE,KAEJ,MAAM2E,EAAyB,CAC3BN,OAAAA,EACArB,UACI,OAAO/B,EAAM+B,KAEjBK,iBACI,OAAOpC,EAAMoC,YAEjBtE,KAAAA,EACA8C,SAAUA,EACV7B,QAASyE,GAGbL,IAEArB,EAAI6B,iBAAiB,WAAYR,GACjC,OAAOO,GAEX,MAAME,EAAQ,CAACC,EAAOC,KAClB,IAAIjC,EACJ,GAAI,OAAQgC,EAAO,CACf,MAAO,CACHb,KAAMa,EAAMb,KACZC,GAAIY,EAAMZ,IAMlB,MAAO,CACHD,KAAMa,EAAMb,KACZe,GAAIF,EAAME,GACVR,KAAM1B,EAAKgC,EAAMG,UAAY,MAAQnC,SAAY,EAAIA,EAAKiC,IAqBlE,MAAMf,EAAY,CAACkB,EAAUjB,KACzB,UAAWA,IAAS,SAAU,CAC1B,GAAIA,IAASiB,EAAU,CACnB,MAAO,SAGV,UAAWjB,IAAS,WAAY,CACjC,MAAMF,EAASE,EAAKiB,GACpB,GAAInB,EAAQ,CACR,OAAOA,IAAW,KACZ,GACA,IAAKA,QAGd,CACD,MAAMoB,EAAUlB,EAAKmB,KAAKF,GAC1B,GAAIC,EAAS,CACTlB,EAAKoB,UAAY,EACjB,MAAO,IAAKF,IAGpB,OAAOhB,WAEX,MAAMf,EAAqBJ,GAChBA,EAAIkC,SAASI,cCrIxB,MAAMC,EAAS3C,QAOF4C,EAAY,+BASrBzK,qBAAuB,OAAOE,KAAKwK,gBAE3B1K,gBACJ,MAAMkJ,EAAOlI,SAASiC,SAASkH,SAE/BQ,MAAM,QAAQzB,gBAAmB0B,MAAMC,IACnC,GAAIA,EAASC,GAAI,CACb,OAAOD,EAASE,OAGpB,MAAM,IAAIC,MAAM,wBAEfJ,MAAMK,IACH,MAAMC,EAAS,IAAIC,UACnB,MAAMC,EAASF,EAAOG,gBAAgBJ,EAAM,aAC5C/K,KAAKkL,OAASA,EAAOE,kBAAkBC,UAEvC,GAAIH,EAAOI,KAAKC,cAAc,UAAW,CACrCvL,KAAKwL,kBAAkBrF,MAAMC,KAAK8E,EAAOnK,iBAAiB,gBAGjE0K,OAAOC,IACJC,QAAQD,MAAMA,MAIlB5L,kBAAkB8L,GACtBlJ,WAAWC,YAAYC,aAEvBgJ,EAAQlL,SAAQ,CAACmL,EAAQrE,KACrB,IAAK1G,SAASwK,KAAKC,cAAc,0BAA0B/D,KAAU,CACjE3E,YAAW,KACP,MAAMiJ,EAAiBhL,SAASiL,cAAc,UAC9CD,EAAe5K,aAAa,KAAM,mBAAmBsG,KACrDsE,EAAeE,UAAYH,EAAOG,UAClClL,SAASwK,KAAKW,YAAYH,KAC3B,QAKfhM,SACI,OACIsD,EAACkH,EAAOlB,OAAM,KACVhG,EAACwG,EAAK,CACFZ,KAAMlI,SAASiC,SAASkH,SACxBD,OAAQ,IACJ5G,EAAA,OAAA,CAAMC,MAAM,YAAY2I,UAAWhM,KAAKkL","sourcesContent":["/**\r\n * Lazy loads images that are set up properly. Aslo handled webp fallbacks\r\n * For img tags:\r\n *      <picture>\r\n            <source class=\"img-load-lazy\" data-srcset=\"/img.jpg\" type=\"image/jpeg\" />\r\n            <img class=\"img-load-lazy\" data-src=\"/img.jpg\" alt=\"Image Alt\" />\r\n        </picture>\r\n    For BG Images: <div class=\"lazy-load-bg\" style=\"background-image: url('/my-image.jpeg')\"></div>\r\n\r\n    more info: https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video\r\n */\r\n\r\nexport class ImageLoader {\r\n    public queue;\r\n\r\n    public backgroundQueue;\r\n\r\n    public lazyImageObserver;\r\n\r\n    public lazyBgObserver;\r\n\r\n    public options;\r\n\r\n    public webpSupported;\r\n\r\n    constructor(options = {}) {\r\n        this.queue = [];\r\n        this.backgroundQueue = [];\r\n        this.lazyImageObserver = null;\r\n        this.lazyBgObserver = null;\r\n        this.options = options;\r\n    }\r\n\r\n    public initialize() {\r\n        this.queue = [];\r\n        this.backgroundQueue = [];\r\n        this.lazyImageObserver = null;\r\n        this.lazyBgObserver = null;\r\n\r\n        this.getImagesToLazyLoad();\r\n\r\n        if (!('IntersectionObserver' in window)) {\r\n            this.abort();\r\n            return;\r\n        }\r\n\r\n        this.onContentLoaded();\r\n        this.setGenericPlaceholder();\r\n\r\n        this.queue.forEach((lazyImage) => {\r\n            this.lazyImageObserver.observe(lazyImage);\r\n        });\r\n\r\n        this.backgroundQueue.forEach((lazyBg) => {\r\n            this.lazyBgObserver.observe(lazyBg);\r\n        });\r\n    }\r\n\r\n    getImagesToLazyLoad() {\r\n        this.queue = document.querySelectorAll('.img-load-lazy');\r\n        this.backgroundQueue = document.querySelectorAll('.lazy-load-bg');\r\n    }\r\n\r\n    setGenericPlaceholder() {\r\n        if (this.options.genericImagePlaceholder) {\r\n            this.queue.forEach((img) => {\r\n                img.setAttribute('src', this.options.genericImagePlaceholder);\r\n            });\r\n        }\r\n\r\n        if (this.options.genericBgPlaceholder) {\r\n            this.backgroundQueue.forEach((bg) => {\r\n                // eslint-disable-next-line no-param-reassign\r\n                bg.style.backgroundColor = this.options.genericBgPlaceholder;\r\n            });\r\n        }\r\n    }\r\n\r\n    onContentLoaded() {\r\n        this.lazyImageObserver = new IntersectionObserver((entries) => {\r\n            entries.forEach((entry) => {\r\n                if (entry.isIntersecting) {\r\n                    const lazyImage: any = entry.target;\r\n\r\n                    if (lazyImage.classList.contains('img-load-lazy')) {\r\n                        if (lazyImage.dataset.src) {\r\n                            lazyImage.src = lazyImage.dataset.src;\r\n                        }\r\n                        if (lazyImage.dataset.srcset) {\r\n                            lazyImage.srcset = lazyImage.dataset.srcset;\r\n                        }\r\n                        lazyImage.classList.remove('img-load-lazy');\r\n                        lazyImage.classList.add('img-hydrated');\r\n                        this.lazyImageObserver.unobserve(lazyImage);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        this.lazyBgObserver = new IntersectionObserver((entries) => {\r\n            entries.forEach((entry) => {\r\n                if (entry.isIntersecting && entry.target.classList.contains('lazy-load-bg')) {\r\n                    const webP = entry.target.getAttribute('data-webp');\r\n                    if (this.webpSupported && webP && webP !== '') {\r\n                        entry.target.setAttribute('style', `background-image: url(${webP})`);\r\n                    }\r\n\r\n                    entry.target.classList.remove('lazy-load-bg');\r\n                    entry.target.classList.add('img-hydrated');\r\n                    this.lazyBgObserver.unobserve(entry.target);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    abort() {\r\n        for (let i = 0; i < this.queue.length; i += 1) {\r\n            this.queue[i].setAttribute('src', this.queue[i].getAttribute('data-src'));\r\n            this.queue[i].classList.remove('img-load-lazy');\r\n            this.queue[i].classList.add('img-hydrated');\r\n        }\r\n\r\n        for (let i = 0; i < this.backgroundQueue.length; i += 1) {\r\n            this.backgroundQueue[i].classList.remove('lazy-load-bg');\r\n        }\r\n    }\r\n}\r\n","import { Component, h } from '@stencil/core';\r\nimport { ImageLoader } from 'utils';\r\n\r\ndeclare global {\r\n    interface Window { imageLoader: any; }\r\n}\r\n\r\n@Component({\r\n    tag: 'app-root',\r\n    shadow: false\r\n})\r\nexport class AppRoot {\r\n    componentWillLoad() {\r\n        globalThis.imageLoader = new ImageLoader();\r\n    }\r\n\r\n    componentDidLoad() {\r\n        globalThis.imageLoader.initialize();\r\n    }\r\n\r\n    componentDidRender() {\r\n        setTimeout(() => {\r\n            const { hash } = window.location;\r\n            if (hash) {\r\n                const elem = document.getElementById(hash.substring(1));\r\n                if (elem) {\r\n                    elem.scrollIntoView();\r\n                }\r\n            }\r\n        }, 500);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div class=\"app-root\">\r\n                <slot />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n","import { getRenderingRef, forceUpdate } from '@stencil/core';\n\nconst appendToMap = (map, propName, value) => {\n    const items = map.get(propName);\n    if (!items) {\n        map.set(propName, [value]);\n    }\n    else if (!items.includes(value)) {\n        items.push(value);\n    }\n};\nconst debounce = (fn, ms) => {\n    let timeoutId;\n    return (...args) => {\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(() => {\n            timeoutId = 0;\n            fn(...args);\n        }, ms);\n    };\n};\n\n/**\n * Check if a possible element isConnected.\n * The property might not be there, so we check for it.\n *\n * We want it to return true if isConnected is not a property,\n * otherwise we would remove these elements and would not update.\n *\n * Better leak in Edge than to be useless.\n */\nconst isConnected = (maybeElement) => !('isConnected' in maybeElement) || maybeElement.isConnected;\nconst cleanupElements = debounce((map) => {\n    for (let key of map.keys()) {\n        map.set(key, map.get(key).filter(isConnected));\n    }\n}, 2000);\nconst stencilSubscription = () => {\n    if (typeof getRenderingRef !== 'function') {\n        // If we are not in a stencil project, we do nothing.\n        // This function is not really exported by @stencil/core.\n        return {};\n    }\n    const elmsToUpdate = new Map();\n    return {\n        dispose: () => elmsToUpdate.clear(),\n        get: (propName) => {\n            const elm = getRenderingRef();\n            if (elm) {\n                appendToMap(elmsToUpdate, propName, elm);\n            }\n        },\n        set: (propName) => {\n            const elements = elmsToUpdate.get(propName);\n            if (elements) {\n                elmsToUpdate.set(propName, elements.filter(forceUpdate));\n            }\n            cleanupElements(elmsToUpdate);\n        },\n        reset: () => {\n            elmsToUpdate.forEach((elms) => elms.forEach(forceUpdate));\n            cleanupElements(elmsToUpdate);\n        },\n    };\n};\n\nconst createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {\n    let states = new Map(Object.entries(defaultState !== null && defaultState !== void 0 ? defaultState : {}));\n    const handlers = {\n        dispose: [],\n        get: [],\n        set: [],\n        reset: [],\n    };\n    const reset = () => {\n        states = new Map(Object.entries(defaultState !== null && defaultState !== void 0 ? defaultState : {}));\n        handlers.reset.forEach((cb) => cb());\n    };\n    const dispose = () => {\n        // Call first dispose as resetting the state would\n        // cause less updates ;)\n        handlers.dispose.forEach((cb) => cb());\n        reset();\n    };\n    const get = (propName) => {\n        handlers.get.forEach((cb) => cb(propName));\n        return states.get(propName);\n    };\n    const set = (propName, value) => {\n        const oldValue = states.get(propName);\n        if (shouldUpdate(value, oldValue, propName)) {\n            states.set(propName, value);\n            handlers.set.forEach((cb) => cb(propName, value, oldValue));\n        }\n    };\n    const state = (typeof Proxy === 'undefined'\n        ? {}\n        : new Proxy(defaultState, {\n            get(_, propName) {\n                return get(propName);\n            },\n            ownKeys(_) {\n                return Array.from(states.keys());\n            },\n            getOwnPropertyDescriptor() {\n                return {\n                    enumerable: true,\n                    configurable: true,\n                };\n            },\n            has(_, propName) {\n                return states.has(propName);\n            },\n            set(_, propName, value) {\n                set(propName, value);\n                return true;\n            },\n        }));\n    const on = (eventName, callback) => {\n        handlers[eventName].push(callback);\n        return () => {\n            removeFromArray(handlers[eventName], callback);\n        };\n    };\n    const onChange = (propName, cb) => {\n        const unSet = on('set', (key, newValue) => {\n            if (key === propName) {\n                cb(newValue);\n            }\n        });\n        const unReset = on('reset', () => cb(defaultState[propName]));\n        return () => {\n            unSet();\n            unReset();\n        };\n    };\n    const use = (...subscriptions) => {\n        const unsubs = subscriptions.reduce((unsubs, subscription) => {\n            if (subscription.set) {\n                unsubs.push(on('set', subscription.set));\n            }\n            if (subscription.get) {\n                unsubs.push(on('get', subscription.get));\n            }\n            if (subscription.reset) {\n                unsubs.push(on('reset', subscription.reset));\n            }\n            if (subscription.dispose) {\n                unsubs.push(on('dispose', subscription.dispose));\n            }\n            return unsubs;\n        }, []);\n        return () => unsubs.forEach((unsub) => unsub());\n    };\n    const forceUpdate = (key) => {\n        const oldValue = states.get(key);\n        handlers.set.forEach((cb) => cb(key, oldValue, oldValue));\n    };\n    return {\n        state,\n        get,\n        set,\n        on,\n        onChange,\n        use,\n        dispose,\n        reset,\n        forceUpdate,\n    };\n};\nconst removeFromArray = (array, item) => {\n    const index = array.indexOf(item);\n    if (index >= 0) {\n        array[index] = array[array.length - 1];\n        array.length--;\n    }\n};\n\nconst createStore = (defaultState, shouldUpdate) => {\n    const map = createObservableMap(defaultState, shouldUpdate);\n    map.use(stencilSubscription());\n    return map;\n};\n\nexport { createObservableMap, createStore };\n","import { Build } from '@stencil/core';\nimport { createStore } from '@stencil/store';\n\nlet defaultRouter;\nconst createRouter = (opts) => {\n    var _a;\n    const win = window;\n    const url = new URL(win.location.href);\n    const parseURL = (_a = opts === null || opts === void 0 ? void 0 : opts.parseURL) !== null && _a !== void 0 ? _a : DEFAULT_PARSE_URL;\n    const { state, onChange, dispose } = createStore({\n        url,\n        activePath: parseURL(url)\n    }, (newV, oldV, prop) => {\n        if (prop === 'url') {\n            return newV.href !== oldV.href;\n        }\n        return newV !== oldV;\n    });\n    const push = (href) => {\n        history.pushState(null, null, href);\n        const url = new URL(href, document.baseURI);\n        state.url = url;\n        state.activePath = parseURL(url);\n    };\n    const match = (routes) => {\n        const { activePath } = state;\n        for (let route of routes) {\n            const params = matchPath(activePath, route.path);\n            if (params) {\n                if (route.to != null) {\n                    const to = (typeof route.to === 'string')\n                        ? route.to\n                        : route.to(activePath);\n                    push(to);\n                    return match(routes);\n                }\n                else {\n                    return { params, route };\n                }\n            }\n        }\n        return undefined;\n    };\n    const navigationChanged = () => {\n        const url = new URL(win.location.href);\n        state.url = url;\n        state.activePath = parseURL(url);\n    };\n    const Switch = (_, childrenRoutes) => {\n        const result = match(childrenRoutes);\n        if (result) {\n            if (typeof result.route.jsx === 'function') {\n                return result.route.jsx(result.params);\n            }\n            else {\n                return result.route.jsx;\n            }\n        }\n    };\n    const disposeRouter = () => {\n        defaultRouter = undefined;\n        win.removeEventListener('popstate', navigationChanged);\n        dispose();\n    };\n    const router = defaultRouter = {\n        Switch,\n        get url() {\n            return state.url;\n        },\n        get activePath() {\n            return state.activePath;\n        },\n        push,\n        onChange: onChange,\n        dispose: disposeRouter,\n    };\n    // Initial update\n    navigationChanged();\n    // Listen URL changes\n    win.addEventListener('popstate', navigationChanged);\n    return router;\n};\nconst Route = (props, children) => {\n    var _a;\n    if ('to' in props) {\n        return {\n            path: props.path,\n            to: props.to,\n        };\n    }\n    if (Build.isDev && props.render && children.length > 0) {\n        console.warn('Route: if `render` is provided, the component should not have any children');\n    }\n    return {\n        path: props.path,\n        id: props.id,\n        jsx: (_a = props.render) !== null && _a !== void 0 ? _a : children,\n    };\n};\nconst href = (href, router = defaultRouter) => {\n    if (Build.isDev && !router) {\n        throw new Error('Router must be defined in href');\n    }\n    return {\n        href,\n        onClick: (ev) => {\n            if (ev.metaKey || ev.ctrlKey) {\n                return;\n            }\n            if (ev.which == 2 || ev.button == 1) {\n                return;\n            }\n            ev.preventDefault();\n            router.push(href);\n        },\n    };\n};\nconst matchPath = (pathname, path) => {\n    if (typeof path === 'string') {\n        if (path === pathname) {\n            return {};\n        }\n    }\n    else if (typeof path === 'function') {\n        const params = path(pathname);\n        if (params) {\n            return params === true\n                ? {}\n                : { ...params };\n        }\n    }\n    else {\n        const results = path.exec(pathname);\n        if (results) {\n            path.lastIndex = 0;\n            return { ...results };\n        }\n    }\n    return undefined;\n};\nconst DEFAULT_PARSE_URL = (url) => {\n    return url.pathname.toLowerCase();\n};\nconst NotFound = () => ({});\n\n/**\n * TS adaption of https://github.com/pillarjs/path-to-regexp/blob/master/index.js\n */\n/**\n * Default configs.\n */\nconst DEFAULT_DELIMITER = '/';\nconst DEFAULT_DELIMITERS = './';\n/**\n * The main path matching regexp utility.\n */\nconst PATH_REGEXP = new RegExp([\n    // Match escaped characters that would otherwise appear in future matches.\n    // This allows the user to escape special characters that won't transform.\n    '(\\\\\\\\.)',\n    // Match Express-style parameters and un-named parameters with a prefix\n    // and optional suffixes. Matches appear as:\n    //\n    // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\"]\n    // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined]\n    '(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?'\n].join('|'), 'g');\n/**\n * Parse a string for the raw tokens.\n */\nconst parse = (str, options) => {\n    var tokens = [];\n    var key = 0;\n    var index = 0;\n    var path = '';\n    var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER;\n    var delimiters = (options && options.delimiters) || DEFAULT_DELIMITERS;\n    var pathEscaped = false;\n    var res;\n    while ((res = PATH_REGEXP.exec(str)) !== null) {\n        var m = res[0];\n        var escaped = res[1];\n        var offset = res.index;\n        path += str.slice(index, offset);\n        index = offset + m.length;\n        // Ignore already escaped sequences.\n        if (escaped) {\n            path += escaped[1];\n            pathEscaped = true;\n            continue;\n        }\n        var prev = '';\n        var next = str[index];\n        var name = res[2];\n        var capture = res[3];\n        var group = res[4];\n        var modifier = res[5];\n        if (!pathEscaped && path.length) {\n            var k = path.length - 1;\n            if (delimiters.indexOf(path[k]) > -1) {\n                prev = path[k];\n                path = path.slice(0, k);\n            }\n        }\n        // Push the current path onto the tokens.\n        if (path) {\n            tokens.push(path);\n            path = '';\n            pathEscaped = false;\n        }\n        var partial = prev !== '' && next !== undefined && next !== prev;\n        var repeat = modifier === '+' || modifier === '*';\n        var optional = modifier === '?' || modifier === '*';\n        var delimiter = prev || defaultDelimiter;\n        var pattern = capture || group;\n        tokens.push({\n            name: name || key++,\n            prefix: prev,\n            delimiter: delimiter,\n            optional: optional,\n            repeat: repeat,\n            partial: partial,\n            pattern: pattern ? escapeGroup(pattern) : '[^' + escapeString(delimiter) + ']+?'\n        });\n    }\n    // Push any remaining characters.\n    if (path || index < str.length) {\n        tokens.push(path + str.substr(index));\n    }\n    return tokens;\n};\n/**\n * Escape a regular expression string.\n */\nconst escapeString = (str) => {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1');\n};\n/**\n * Escape the capturing group by escaping special characters and meaning.\n */\nconst escapeGroup = (group) => {\n    return group.replace(/([=!:$/()])/g, '\\\\$1');\n};\n/**\n * Get the flags for a regexp from the options.\n */\nconst flags = (options) => {\n    return options && options.sensitive ? '' : 'i';\n};\n/**\n * Pull out keys from a regexp.\n */\nconst regexpToRegexp = (path, keys) => {\n    if (!keys)\n        return path;\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g);\n    if (groups) {\n        for (var i = 0; i < groups.length; i++) {\n            keys.push({\n                name: i,\n                prefix: null,\n                delimiter: null,\n                optional: false,\n                repeat: false,\n                partial: false,\n                pattern: null\n            });\n        }\n    }\n    return path;\n};\n/**\n * Transform an array into a regexp.\n */\nconst arrayToRegexp = (path, keys, options) => {\n    var parts = [];\n    for (var i = 0; i < path.length; i++) {\n        parts.push(pathToRegexp(path[i], keys, options).source);\n    }\n    return new RegExp('(?:' + parts.join('|') + ')', flags(options));\n};\n/**\n * Create a path regexp from string input.\n */\nconst stringToRegexp = (path, keys, options) => {\n    return tokensToRegExp(parse(path, options), keys, options);\n};\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nconst tokensToRegExp = (tokens, keys, options) => {\n    options = options || {};\n    var strict = options.strict;\n    var end = options.end !== false;\n    var delimiter = escapeString(options.delimiter || DEFAULT_DELIMITER);\n    var delimiters = options.delimiters || DEFAULT_DELIMITERS;\n    var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|');\n    var route = '';\n    var isEndDelimited = false;\n    // Iterate over the tokens and create our regexp string.\n    for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n        if (typeof token === 'string') {\n            route += escapeString(token);\n            isEndDelimited = i === tokens.length - 1 && delimiters.indexOf(token[token.length - 1]) > -1;\n        }\n        else {\n            var prefix = escapeString(token.prefix || '');\n            var capture = token.repeat\n                ? '(?:' + token.pattern + ')(?:' + prefix + '(?:' + token.pattern + '))*'\n                : token.pattern;\n            if (keys)\n                keys.push(token);\n            if (token.optional) {\n                if (token.partial) {\n                    route += prefix + '(' + capture + ')?';\n                }\n                else {\n                    route += '(?:' + prefix + '(' + capture + '))?';\n                }\n            }\n            else {\n                route += prefix + '(' + capture + ')';\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += '(?:' + delimiter + ')?';\n        route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';\n    }\n    else {\n        if (!strict)\n            route += '(?:' + delimiter + '(?=' + endsWith + '))?';\n        if (!isEndDelimited)\n            route += '(?=' + delimiter + '|' + endsWith + ')';\n    }\n    return new RegExp('^' + route, flags(options));\n};\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nconst pathToRegexp = (path, keys, options) => {\n    if (path instanceof RegExp) {\n        return regexpToRegexp(path, keys);\n    }\n    if (Array.isArray(path)) {\n        return arrayToRegexp(path, keys, options);\n    }\n    return stringToRegexp(path, keys, options);\n};\n\nlet cacheCount = 0;\nconst patternCache = {};\nconst cacheLimit = 10000;\n// Memoized function for creating the path match regex\nconst compilePath = (pattern, options) => {\n    const cacheKey = `${options.end}${options.strict}`;\n    const cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\n    const cachePattern = JSON.stringify(pattern);\n    if (cache[cachePattern]) {\n        return cache[cachePattern];\n    }\n    const keys = [];\n    const re = pathToRegexp(pattern, keys, options);\n    const compiledPattern = { re, keys };\n    if (cacheCount < cacheLimit) {\n        cache[cachePattern] = compiledPattern;\n        cacheCount += 1;\n    }\n    return compiledPattern;\n};\nconst match = (pathname, options = {}) => {\n    const { exact = false, strict = false } = options;\n    const { re, keys } = compilePath(pathname, { end: exact, strict });\n    return (path) => {\n        const match = re.exec(path);\n        if (!match) {\n            return undefined;\n        }\n        const [url, ...values] = match;\n        const isExact = path === url;\n        if (exact && !isExact) {\n            return undefined;\n        }\n        return keys.reduce((memo, key, index) => {\n            memo[key.name] = values[index];\n            return memo;\n        }, {});\n    };\n};\n\nexport { NotFound, Route, createRouter, href, match };\n","import {\r\n    Component,\r\n    h,\r\n    Prop,\r\n    Element\r\n} from '@stencil/core';\r\nimport { createRouter, Route } from 'stencil-router-v2';\r\n\r\nconst Router = createRouter();\r\n\r\n@Component({\r\n    tag: 'static-router',\r\n    shadow: false\r\n})\r\n\r\nexport class StaticRouter {\r\n    @Element() root: HTMLElement;\r\n\r\n    /**\r\n     * Contains the active page's markup from\r\n     * the node server\r\n     */\r\n    @Prop({ mutable: true }) markup: any;\r\n\r\n    componentDidRender() { return this.fetchContents(); }\r\n\r\n    private fetchContents() {\r\n        const path = document.location.pathname;\r\n\r\n        fetch(`/html${path}/index.html`).then((response) => {\r\n            if (response.ok) {\r\n                return response.text();\r\n            }\r\n\r\n            throw new Error('missing component');\r\n        })\r\n            .then((data) => {\r\n                const parser = new DOMParser();\r\n                const markup = parser.parseFromString(data, 'text/html');\r\n                this.markup = markup.firstElementChild.outerHTML;\r\n\r\n                if (markup.body.querySelector('script')) {\r\n                    this.injectBodyScripts(Array.from(markup.querySelectorAll('script')));\r\n                }\r\n            })\r\n            .catch((error) => {\r\n                console.error(error);\r\n            });\r\n    }\r\n\r\n    private injectBodyScripts(scripts:Array<HTMLScriptElement>) {\r\n        globalThis.imageLoader.initialize();\r\n\r\n        scripts.forEach((script, index) => {\r\n            if (!document.body.querySelector(`script#injected-script_${index}`)) {\r\n                setTimeout(() => {\r\n                    const injectedScript = document.createElement('script');\r\n                    injectedScript.setAttribute('id', `injected-script_${index}`);\r\n                    injectedScript.innerHTML = script.innerHTML;\r\n                    document.body.appendChild(injectedScript);\r\n                }, 50);\r\n            }\r\n        });\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <Router.Switch>\r\n                <Route\r\n                    path={document.location.pathname}\r\n                    render={() => (\r\n                        <main class=\"page-root\" innerHTML={this.markup} />\r\n                    )}\r\n                />\r\n            </Router.Switch>\r\n        );\r\n    }\r\n}\r\n"]}